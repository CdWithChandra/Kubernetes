
# Kubernetes For Beginners -Running Notes!


What is Pod?
  Smallest object that you create in a kubernetes.

Types of Pods?
  - two types 
  - single container Pods
  - multi-container pod 

# - single container Pods
  spec:
    containers:
      - name: nginx-conteiner 
        image: nginx 

#  - multi-container pod 
 spec:
    containers:
      - name: nginx-conteiner 
        image: nginx 
      - name: redis-container 
        image: redis 


Top level of fields or attributes Pod YAML?
  
  - apiVersion: v1 
  - kind: Pod 
  - metadata: 
  - spec: 

init vs Multi-Container Pods?
  - initContainers:
      - name: download-conifg 
        image: nginx 


Real World Examples with demo


Summary Commands:
  kubectl create -f myapp.yml 
  kubectl run nginx-pod --image=nginx 
  kubectl get pods 
  kubectl describe pod [mypod-pod name]
  kubectl delete pod [mypod-pod name]
  kubectl get pods -o wide  


Top 10 Essential kuebctl commands For deployments:

kubectl create -f my-app.yml 

kubectl create deployment my-app --image=nginx 

kubectl get deployments -o wide 

kubectl describe deployment my-app 

kubectl rollout status deployment/my-app 

kubectl rollout undo deployment/my-app 

kubectl scale deployment/my-app --replicas=3

kubectl set image deployment/my-app container=my-container:new-image

kubectl expose deployment/my-app --type=LoadBalancer --port=80

kubectl delete deploymnet my-app 


# What are init containers - Full Breakdown 

Init containers are powerful feature in Kubernetes that run before your main application containers in a pod, ensuring the
dependencies are ready. They'r essential for reliable deployments, like setting up simple inital steps or verifying basics.

In this You'll learn:
---------------------

1. What they are?
2. How they work?
3. Simple example with demo


1. What are init Containers:
   init containers are special containers in a pod spec that executes sequentially, before the main containers start.

   they are handling one time setups or tasks sucha as , printing a msg, setting up db before your main containers start.


Key features:
they must complete successfully to proceed the pod.
Any failures restart the pod 

They run in the main containers, sharing the same storage and network namespace.
They don't run in parallel, strict order it will executes.
Supported in Pods, deployments, Statefulset etc.


2. How they work?:

Pod phases involved- During the pending phase, init containers run one by one. once all completed/succeeded pod moves to
running state and starts the main ontainers.


Excuttion Flow:
  Pod creation -> init container1 starts ->success -> init container2 if any ->all done (init containers) -> Main container



3. Simple example with demo:

apiVersion: v1
kind: Pod
metadata:
  name: my-app-pod 
spec:
  initContainers:
    - name: initial-setup 
      image: busybox # lightweight image for simple commands 
      command: ['sh','-c','echo "Setting uo env", sleep 2; echo "Init complete! Starting up main app...";']
  containers:
    - name: nginx-container
      image: nginx 
      ports:
        - containerPort: 80

Real - World usecases:
  Dependency waiting- print status or simulate checks before app startup - it prevents startup failures 
  Data initialisation - o/p setup confiramtions 
  Security Checks - Log credential checks or generate simple markers before main containers access them 
  Testing/Validation - print verification msg on shared volumes.


Best Practices:
  keep lightweight images
  Error Handling 
  Security 


Top 5 Kubernetes Mistakes Beginners Make 
(And How to Fix Them Fast!)
----------------------------------------

1. Manual Pod Creation:

   apiVersion: v1
   kind: Pod
   metadata:
     name: my-pod
   spec:
     containers:
       - name: nginx-container
         image: nginx 

kubectl create deploy mydeploy --image=nginx 

2. Not Using Deployments for ReplicaSets:
   
kubectl create deploy mydeploy --image=busybox


3. Ignoring Namespaces
   
   apiVersion: v1
   kind: Pod
   metadata:
     name: [insert-namespace-name] 
   
   or 

kubectl create namespace [insert-namespace-name]
kubectl delete namespaces [insert-namespace-name]

4. Overlooking Resource Limits:
    
    spec:
      contaienrs:
        reources: 
          limits:
            cpu: "500m" limit cpu to half 
            memory: "512Mi" limit to 512 mb


5. Misconfiguring Networking/Services:
   
apiVersion: v1
kind: Service
metadata:
  name: my-bad-service
spec:
  selector:
    app: nginx
  ports:
  - protocol: TCP
    port: 80  #  
  type: ClusterIP  # Wrong for external access;



Kubernetes vs Docker Swarm? Choose the best! 

Intro:
Which Orchestration tool will supercharge your Python projects and land you that dream job: Kubernetes or Docker Swarm?


Here's the break down you can choose the Winner and stay ahed!
--------------------------------------------------------------

What is Docker Swarm?:
Docker Swarm is a simple tool for managing Docker containers in a cluster, great for smaller projects.


What is Kubernetes?:
K8 is a Powerful Orchestration tool for managing, scaling and deploing applications, ideal for larger and complex setups.


What are the key differences?:
K8 offers advanced features like autoscaling with Horiontal Pod autoscaler (HPA) while docker Swarm is esaier for beginners.
For Python projects, Kubernetes handles microservices better, but swarm is quick and esay to setup.

Which to choose? Go with Kubernetes for growth potential, Go with swarm you want simplicity.


That's it 

Will see the demo for Docker swarm and Kubernetes:


1. Docker Swarm Example (docker-compose.yml):

A simple file to deploy an application 

docker-compose.yml 
------------------
version: '3'  # docker compose version 
services:
  web:
    image: my-python-app:latest  # actual image may vary check before using 
    deploy:
      replicas: 2    # no of replciacs 


Deploy an application:

docker stack deploy -c docker-compose.yml mystack  - for creation 

docker stack ls     - To list 
docker network ls   - To list networks 
docker service ls   - To list services 

For removing:

docker stack rm mystack             - To remove stack 
docker network rm [name-of-network] - To remove network
docker service rm [name-of-service] - To remvoe service 



2. Kubernetes Example:

A minimal file to deploy python application

deployment.yml
--------------

apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-python-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-container
        image: nginx


Deploy an application: 

kubectl create -f deployment.yml              - for creation 
kubectl get deploy or kubectl get deployments - To list deployments 
kubectl describe deploy [name-of-deploy]      - To get addional info 
kubectl delete deploy [name-of-deploy]        - To delete deployment 




































































