
# Kubernetes For Beginners -Running Notes!


What is Pod?
  Smallest object that you create in a kubernetes.

Types of Pods?
  - two types 
  - single container Pods
  - multi-container pod 

# - single container Pods
  spec:
    containers:
      - name: nginx-conteiner 
        image: nginx 

#  - multi-container pod 
 spec:
    containers:
      - name: nginx-conteiner 
        image: nginx 
      - name: redis-container 
        image: redis 


Top level of fields or attributes Pod YAML?
  
  - apiVersion: v1 
  - kind: Pod 
  - metadata: 
  - spec: 

init vs Multi-Container Pods?
  - initContainers:
      - name: download-conifg 
        image: nginx 


Real World Examples with demo


Summary Commands:
  kubectl create -f myapp.yml 
  kubectl run nginx-pod --image=nginx 
  kubectl get pods 
  kubectl describe pod [mypod-pod name]
  kubectl delete pod [mypod-pod name]
  kubectl get pods -o wide  


Top 10 Essential kuebctl commands For deployments:

kubectl create -f my-app.yml 

kubectl create deployment my-app --image=nginx 

kubectl get deployments -o wide 

kubectl describe deployment my-app 

kubectl rollout status deployment/my-app 

kubectl rollout undo deployment/my-app 

kubectl scale deployment/my-app --replicas=3

kubectl set image deployment/my-app container=my-container:new-image

kubectl expose deployment/my-app --type=LoadBalancer --port=80

kubectl delete deploymnet my-app 


# What are init containers - Full Breakdown 

Init containers are powerful feature in Kubernetes that run before your main application containers in a pod, ensuring the
dependencies are ready. They'r essential for reliable deployments, like setting up simple inital steps or verifying basics.

In this You'll learn:
---------------------

1. What they are?
2. How they work?
3. Simple example with demo


1. What are init Containers:
   init containers are special containers in a pod spec that executes sequentially, before the main containers start.

   they are handling one time setups or tasks sucha as , printing a msg, setting up db before your main containers start.


Key features:
they must complete successfully to proceed the pod.
Any failures restart the pod 

They run in the main containers, sharing the same storage and network namespace.
They don't run in parallel, strict order it will executes.
Supported in Pods, deployments, Statefulset etc.


2. How they work?:

Pod phases involved- During the pending phase, init containers run one by one. once all completed/succeeded pod moves to
running state and starts the main ontainers.


Excuttion Flow:
  Pod creation -> init container1 starts ->success -> init container2 if any ->all done (init containers) -> Main container



3. Simple example with demo:

apiVersion: v1
kind: Pod
metadata:
  name: my-app-pod 
spec:
  initContainers:
    - name: initial-setup 
      image: busybox # lightweight image for simple commands 
      command: ['sh','-c','echo "Setting uo env", sleep 2; echo "Init complete! Starting up main app...";']
  containers:
    - name: nginx-container
      image: nginx 
      ports:
        - containerPort: 80

Real - World usecases:
  Dependency waiting- print status or simulate checks before app startup - it prevents startup failures 
  Data initialisation - o/p setup confiramtions 
  Security Checks - Log credential checks or generate simple markers before main containers access them 
  Testing/Validation - print verification msg on shared volumes.


Best Practices:
  keep lightweight images
  Error Handling 
  Security 


Top 5 Kubernetes Mistakes Beginners Make 
(And How to Fix Them Fast!)
----------------------------------------

1. Manual Pod Creation:

   apiVersion: v1
   kind: Pod
   metadata:
     name: my-pod
   spec:
     containers:
       - name: nginx-container
         image: nginx 

kubectl create deploy mydeploy --image=nginx 

2. Not Using Deployments for ReplicaSets:
   
kubectl create deploy mydeploy --image=busybox


3. Ignoring Namespaces
   
   apiVersion: v1
   kind: Pod
   metadata:
     name: [insert-namespace-name] 
   
   or 

kubectl create namespace [insert-namespace-name]
kubectl delete namespaces [insert-namespace-name]

4. Overlooking Resource Limits:
    
    spec:
      contaienrs:
        reources: 
          limits:
            cpu: "500m" limit cpu to half 
            memory: "512Mi" limit to 512 mb


5. Misconfiguring Networking/Services:
   
apiVersion: v1
kind: Service
metadata:
  name: my-bad-service
spec:
  selector:
    app: nginx
  ports:
  - protocol: TCP
    port: 80  #  
  type: ClusterIP  # Wrong for external access;



Kubernetes vs Docker Swarm? Choose the best! 

Intro:
Which Orchestration tool will supercharge your Python projects and land you that dream job: Kubernetes or Docker Swarm?


Here's the break down you can choose the Winner and stay ahed!
--------------------------------------------------------------

What is Docker Swarm?:
Docker Swarm is a simple tool for managing Docker containers in a cluster, great for smaller projects.


What is Kubernetes?:
K8 is a Powerful Orchestration tool for managing, scaling and deploing applications, ideal for larger and complex setups.


What are the key differences?:
K8 offers advanced features like autoscaling with Horiontal Pod autoscaler (HPA) while docker Swarm is esaier for beginners.
For Python projects, Kubernetes handles microservices better, but swarm is quick and esay to setup.

Which to choose? Go with Kubernetes for growth potential, Go with swarm you want simplicity.


That's it 

Will see the demo for Docker swarm and Kubernetes:


1. Docker Swarm Example (docker-compose.yml):

A simple file to deploy an application 

docker-compose.yml 
------------------
version: '3'  # docker compose version 
services:
  web:
    image: my-python-app:latest  # actual image may vary check before using 
    deploy:
      replicas: 2    # no of replciacs 


Deploy an application:

docker stack deploy -c docker-compose.yml mystack  - for creation 

docker stack ls     - To list 
docker network ls   - To list networks 
docker service ls   - To list services 

For removing:

docker stack rm mystack             - To remove stack 
docker network rm [name-of-network] - To remove network
docker service rm [name-of-service] - To remvoe service 



2. Kubernetes Example:

A minimal file to deploy python application

deployment.yml
--------------

apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-python-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-container
        image: nginx


Deploy an application: 

kubectl create -f deployment.yml              - for creation 
kubectl get deploy or kubectl get deployments - To list deployments 
kubectl describe deploy [name-of-deploy]      - To get addional info 
kubectl delete deploy [name-of-deploy]        - To delete deployment 




Master Kubernetes: 1.34 - The Future of Cloud-Native Development!
-----------------------------------------------------------------


Ready to Master let's deploy your first application in minutes 

step 1:
download Minikube for local kubernetes and start.

step 2:
Write yaml for deployment our first application

step 3:
Expose and access your application 


video Guide: Limited time, maximum impact
link - https://youtube.com/shorts/XRBW0-DUMZc




Cost-Effective Kubernetes Strategies for Beginners
--------------------------------------------------

Struggling with Kubernetes costs as a beginner? Let's slash them without sacrificing performance!

3 Key Strategies to get you started: 

1. Go Managed: Use free tiers of Google Kubernetes Engine (GKE), Amazon EKS, or Azure AKS. 
They handle infrastructure so you pay only for what you use—no upfront servers!

2. Right-Size Resources: Enable Horizontal Pod Autoscaler (HPA) to scale pods automatically. 
Use spot instances for non-critical workloads—up to 90% cheaper!

3. Monitor & Optimize: Install free tools like Prometheus or Kubecost to track spending. 
Delete unused resources and use efficient storage like Persistent Volumes with cheaper classes.


Remember, start small—test on a free cluster like Minikube!

Demos:
YAML with commands!


1. Go Managed: Deploy a Simple App to Leverage Managed Infrastructure


nginx-deployment.yaml
---------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-app
spec:
  replicas: 1  # Start small to keep costs low
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:alpine  # Lightweight image to save resources
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: LoadBalancer 


2. Right-Size Resources: Use Autoscaling to Match Demand


autoscaling-app.yaml
--------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sample-app
spec:
  replicas: 1  # Start with 1 to minimize initial cost
  selector:
    matchLabels:
      app: sample
  template:
    metadata:
      labels:
        app: sample
    spec:
      containers:
      - name: app
        image: nginx:alpine  # Simple app; replace with your own
        ports:
        - containerPort: 80
        resources:
          requests:
            cpu: 100m  # Request minimal CPU
          limits:
            cpu: 200m  # Limit to prevent overuse
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: sample-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: sample-app
  minReplicas: 1
  maxReplicas: 5
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 50  # Scale up if CPU > 50%


3. Monitor & Optimize: Track and Clean Up Unused Resources

monitoring-cleanup.yml
----------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus
spec:
  replicas: 1  # Minimal setup for beginners
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      containers:
      - name: prometheus
        image: prom/prometheus:v2.40.0  # Free monitoring tool
        ports:
        - containerPort: 9090
        volumeMounts:
        - name: config-volume
          mountPath: /etc/prometheus
        - name: storage-volume
          mountPath: /prometheus  # For basic data persistence
      volumes:
      - name: config-volume
        configMap:
          name: prometheus-config
      - name: storage-volume
        emptyDir: {}  # Temporary storage; use PVC for persistence in real setups
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
    scrape_configs:
      - job_name: 'kubernetes-pods'
        kubernetes_sd_configs:
          - role: pod
---
apiVersion: batch/v1
kind: Job
metadata:
  name: cleanup-job
spec:
  template:
    spec:
      containers:
      - name: cleanup
        image: busybox  # Lightweight; no kubectl needed here
        command: ["sh", "-c", "echo 'Simulating cleanup: Checking for unused resources...' && ls /tmp"]  # Simple demo command; replace with real logic if needed
      restartPolicy: Never





















































